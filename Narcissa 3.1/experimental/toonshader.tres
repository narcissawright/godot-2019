[gd_resource type="ShaderMaterial" load_steps=2 format=2]

[sub_resource type="Shader" id=1]
code = "shader_type spatial;
//render_mode ambient_light_disabled;
uniform float celness : hint_range(0,1);
uniform float shadow_amt : hint_range(0,1);

//this varying retrieve uv for usage in light pass!
varying vec2 uv;

//vertex pass -> retriev uv from mesh's UV main channel (channel 0 I think) & will retrieve vertex color for thresholding lighting
void vertex()
{
	uv = UV;
}

void fragment()
{
	ALBEDO = COLOR.rgb;
}

//This function is used to calculate NdotL
float calc_NdotL(vec3 normal, vec3 light)
{
	float NdotL = dot(light, normal);
	return NdotL;
}

//This function is used for calculate shading
bool calc_shading(float sm)
{
	if(sm > 0.5) {
		return true;
	} else {
		return false;
	}
}

//light pass -> we get LIGHT vector and normalize it, calculate the NdotL, calculate shading and appy LIGHT
//REMEMBER that we aren't really using LIGHT_COLOUR, so it won't affect the mesh colour!
void light()
{
	vec3 light = normalize(LIGHT);
	vec3 shadow = ALBEDO * vec3(0.3,0.3,0.75);
	float NdotL = calc_NdotL(NORMAL, light);
	float sm = smoothstep(0.0, 1.0, NdotL);
	bool shade = calc_shading(sm);
	
	float intensity = (LIGHT_COLOR.r + LIGHT_COLOR.g + LIGHT_COLOR.b) / 3.0;
	vec3 shadow_final = ALBEDO*shadow*LIGHT_COLOR*shadow_amt;
	vec3 remainder = ALBEDO * LIGHT_COLOR - shadow_final;
	vec3 non_cel = (shadow_final) + (remainder * sm);
	vec3 cel;
	if(shade == true) {
		cel = ALBEDO * LIGHT_COLOR;
	} else {
		cel = ALBEDO*shadow * LIGHT_COLOR * shadow_amt;
	}
	DIFFUSE_LIGHT += (non_cel * (1.0 - celness)) + (cel * celness);
}"

[resource]
shader = SubResource( 1 )
shader_param/celness = 1.0
shader_param/shadow_amt = 0.154

